---
globs: *.dart
alwaysApply: true
---
# Layer Dependencies Rules

## MANDATORY: Clean Architecture Layer Dependencies

### Layer Dependency Flow
```
Presentation Layer ‚Üí Domain Layer ‚Üê Data Layer
```

### ‚úÖ CORRECT: Allowed Dependencies

#### Presentation Layer Dependencies
- ‚úÖ **Presentation layer CAN depend on domain layer**
- ‚úÖ **Presentation layer CAN use BLoC pattern**
- ‚úÖ **Presentation layer CAN use widgets and UI components**
- ‚ùå **Presentation layer CANNOT depend on data layer directly**

#### Domain Layer Dependencies
- ‚úÖ **Domain layer is independent** (no external dependencies)
- ‚úÖ **Domain layer contains business entities**
- ‚úÖ **Domain layer contains repository interfaces**
- ‚úÖ **Domain layer contains use cases**
- ‚ùå **Domain layer CANNOT depend on data or presentation**

#### Data Layer Dependencies
- ‚úÖ **Data layer CAN depend on domain layer** (implements domain interfaces)
- ‚úÖ **Data layer contains repository implementations**
- ‚úÖ **Data layer contains data sources**
- ‚úÖ **Data layer contains models/DTOs**
- ‚ùå **Data layer CANNOT depend on presentation layer**

### Dependency Flow Examples

#### ‚úÖ CORRECT: Presentation ‚Üí Domain
```dart
// lib/features/auth/presentation/pages/login_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// ‚úÖ CORRECT: Presentation depends on domain
import 'package:my_app/features/auth/domain/entities/user_entity.dart';
import 'package:my_app/features/auth/domain/usecases/login_usecase.dart';
import 'package:my_app/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:my_app/features/auth/presentation/bloc/auth_event.dart';
import 'package:my_app/features/auth/presentation/bloc/auth_state.dart';

class LoginScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<AuthBloc, AuthState>(
      builder: (context, state) {
        return switch (state) {
          AuthLoading() => const CircularProgressIndicator(),
          AuthSuccess(user: final user) => UserProfile(user: user),
          AuthError(message: final error) => ErrorWidget(message: error),
          _ => const LoginForm(),
        };
      },
    );
  }
}
```

#### ‚úÖ CORRECT: Data ‚Üí Domain
```dart
// lib/features/auth/data/repositories/auth_repository_impl.dart
import 'package:my_app/features/auth/domain/entities/user_entity.dart';
import 'package:my_app/features/auth/domain/repositories/auth_repository.dart';

// ‚úÖ CORRECT: Data implements domain interface
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource _remoteDataSource;
  
  AuthRepositoryImpl(this._remoteDataSource);
  
  @override
  Future<UserEntity?> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      final userModel = await _remoteDataSource.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      return userModel?.toEntity();
    } catch (e) {
      throw AuthException('Authentication failed: ${e.toString()}');
    }
  }
}
```

#### ‚úÖ CORRECT: Domain Independence
```dart
// lib/features/auth/domain/entities/user_entity.dart
// ‚úÖ CORRECT: Domain entity is pure Dart class
class UserEntity {
  final String id;
  final String email;
  final String name;
  
  const UserEntity({
    required this.id,
    required this.email,
    required this.name,
  });
}

// lib/features/auth/domain/repositories/auth_repository.dart
// ‚úÖ CORRECT: Domain interface is abstract
abstract class AuthRepository {
  Future<UserEntity?> signInWithEmailAndPassword({
    required String email,
    required String password,
  });
  
  Future<void> signOut();
}

// lib/features/auth/domain/usecases/login_usecase.dart
// ‚úÖ CORRECT: UseCase depends only on domain
class LoginUseCase extends UseCase<UserEntity, LoginParams> {
  final AuthRepository _repository;
  
  LoginUseCase(this._repository);
  
  @override
  Future<Either<Failure, UserEntity>> call(LoginParams params) async {
    try {
      final user = await _repository.signInWithEmailAndPassword(
        email: params.email,
        password: params.password,
      );
      
      if (user != null) {
        return Right(user);
      } else {
        return Left(AuthFailure('Invalid credentials'));
      }
    } catch (e) {
      return Left(AuthFailure(e.toString()));
    }
  }
}
```

## ‚ùå VIOLATIONS: Forbidden Dependencies

### ‚ùå WRONG: Presentation ‚Üí Data
```dart
// ‚ùå WRONG: Presentation directly depends on data layer
import 'package:my_app/features/auth/data/repositories/auth_repository_impl.dart';
import 'package:my_app/features/auth/data/models/user_model.dart';

class LoginScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // ‚ùå WRONG: Direct data layer usage
    final repository = AuthRepositoryImpl();
    final user = await repository.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
  }
}
```

### ‚ùå WRONG: Domain ‚Üí Data
```dart
// ‚ùå WRONG: Domain depends on data layer
import 'package:my_app/features/auth/data/models/user_model.dart';

class UserEntity {
  final String id;
  final String email;
  
  // ‚ùå WRONG: Domain entity depends on data model
  factory UserEntity.fromModel(UserModel model) {
    return UserEntity(
      id: model.id,
      email: model.email,
    );
  }
}
```

### ‚ùå WRONG: Data ‚Üí Presentation
```dart
// ‚ùå WRONG: Data layer depends on presentation
import 'package:flutter/material.dart';
import 'package:my_app/features/auth/presentation/bloc/auth_bloc.dart';

class AuthRepositoryImpl implements AuthRepository {
  // ‚ùå WRONG: Data layer knows about presentation
  void notifyUI(AuthBloc bloc) {
    bloc.add(AuthStateChanged());
  }
}
```

## MANDATORY: Import Organization

### ‚úÖ CORRECT: Import Structure
```dart
// Flutter imports
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// Package imports
import 'package:go_router/go_router.dart';

// Project imports - Core
import 'package:my_app/core/core_exports.dart';

// Project imports - Domain (allowed for presentation)
import 'package:my_app/features/auth/domain/entities/user_entity.dart';
import 'package:my_app/features/auth/domain/usecases/login_usecase.dart';

// Project imports - Presentation
import 'package:my_app/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:my_app/features/auth/presentation/widgets/login_form.dart';

// ‚ùå NEVER import data layer in presentation
// import 'package:my_app/features/auth/data/repositories/auth_repository_impl.dart';
```

## MANDATORY: Dependency Injection Compliance

### ‚úÖ CORRECT: DI Registration Order
```dart
void setupAuthModule(GetIt sl) {
  // 1. Data layer (implements domain interfaces)
  sl.registerLazySingleton<AuthRepository>(
    () => AuthRepositoryImpl(sl()),
  );
  
  // 2. Domain layer (use cases depend on repositories)
  sl.registerLazySingleton<LoginUseCase>(
    () => LoginUseCase(sl()),
  );
  
  // 3. Presentation layer (BLoCs depend on use cases)
  sl.registerFactory<AuthBloc>(
    () => AuthBloc(loginUseCase: sl()),
  );
}
```

## ‚ùå Violations
- **Presentation layer importing from data layer** (e.g., `import 'data/repositories/...'`)
- **Domain layer importing from data layer** (e.g., `import 'data/models/...'`)
- **Data layer importing from presentation layer** (e.g., `import 'presentation/bloc/...'`)
- **Domain entities depending on external frameworks**
- **UseCases calling data layer directly** instead of through repository interfaces
- **Widgets calling repository implementations directly**

## ‚úÖ Correct Patterns
- **Presentation layer depends only on domain layer**
- **Domain layer is completely independent**
- **Data layer implements domain interfaces**
- **UseCases depend only on domain repositories**
- **BLoCs depend only on domain use cases**
- **Clean separation of concerns between layers**

## üí° Best Practices
- Keep domain layer pure and framework-independent
- Use repository pattern to abstract data access
- Test each layer independently
- Use dependency injection to manage layer dependencies
- Document layer boundaries clearly
- Avoid circular dependencies between layers
