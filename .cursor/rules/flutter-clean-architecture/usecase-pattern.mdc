---
globs: *.dart
alwaysApply: true
---

# UseCase Pattern Requirements

## MANDATORY: UseCase Structure

### Base UseCase Class
```dart
sealed class UseCaseResult<T> {
  const UseCaseResult();
  factory UseCaseResult.success([T? data]) = UseCaseSuccess<T>;
  factory UseCaseResult.failure(String error) = UseCaseFailure<T>;
}

final class UseCaseSuccess<T> extends UseCaseResult<T> {
  final T? data;
  const UseCaseSuccess([this.data]);
}

final class UseCaseFailure<T> extends UseCaseResult<T> {
  final String error;
  const UseCaseFailure(this.error);
}

abstract class UseCase<ReturnType, ParamsType> {
  Future<UseCaseResult<ReturnType>> call(ParamsType params);
}

abstract class UseCaseParams {
  const UseCaseParams();
}
```

### UseCase Implementation Requirements
- **All use cases MUST be placed in `domain/usecases/`**
- **UseCase class MUST be named `*UseCase`** (e.g., `GetUserUseCase`, `LoginUseCase`)
- **UseCase MUST extend `UseCase<ReturnType, ParamsType>`**
- **ParamsType MUST extend `UseCaseParams`**
- **UseCase MUST use sealed UseCaseResult pattern** for error handling

### UseCase Error Handling Pattern
```dart
class GetUserUseCase extends UseCase<UserEntity, GetUserParams> {
  final UserRepository _repository;
  
  GetUserUseCase(this._repository);
  
  @override
  Future<UseCaseResult<UserEntity>> call(GetUserParams params) async {
    try {
      // Validate input
      if (params.userId.isEmpty) {
        return UseCaseResult.failure('User ID is required');
      }

      final user = await _repository.getUser(params.userId);
      return UseCaseResult.success(user);
    } catch (e) {
      return UseCaseResult.failure('Failed to get user:  [${e.toString()}');
    }
  }
}

class DeleteUserUseCase extends UseCase<void, DeleteUserParams> {
  final UserRepository _repository;
  
  DeleteUserUseCase(this._repository);
  
  @override
  Future<UseCaseResult<void>> call(DeleteUserParams params) async {
    try {
      // Validate input
      if (params.userId.isEmpty) {
        return UseCaseResult.failure('User ID is required');
      }

      await _repository.deleteUser(params.userId);
      return UseCaseResult.success(); // No data returned
    } catch (e) {
      return UseCaseResult.failure('Failed to delete user: ${e.toString()}');
    }
  }
}
```

### Params Classes
```dart
class GetUserParams extends UseCaseParams {
  final String userId;
  
  const GetUserParams({required this.userId});
}

class DeleteUserParams extends UseCaseParams {
  final String userId;
  
  const DeleteUserParams({required this.userId});
}
```

## ‚ùå Violations
- UseCase class not named `*UseCase`
- UseCase not extending `UseCase<ReturnType, ParamsType>`
- ParamsType not extending `UseCaseParams`
- UseCase placed outside `domain/usecases/`
- UseCase methods without try-catch blocks
- UseCase methods throwing exceptions instead of returning UseCaseResult
- Missing input validation in UseCases
- Not using sealed UseCaseResult for error handling

## ‚úÖ Correct Examples
```dart
// ‚úÖ CORRECT: Proper UseCase implementation
class LoginUseCase extends UseCase<UserEntity, LoginParams> {
  final AuthRepository _repository;
  
  LoginUseCase(this._repository);
  
  @override
  Future<UseCaseResult<UserEntity>> call(LoginParams params) async {
    try {
      if (params.email.isEmpty || params.password.isEmpty) {
        return UseCaseResult.failure('Email and password are required');
      }
      
      final user = await _repository.login(params.email, params.password);
      return UseCaseResult.success(user);
    } catch (e) {
      return UseCaseResult.failure('Login failed: ${e.toString()}');
    }
  }
}

class LoginParams extends UseCaseParams {
  final String email;
  final String password;
  
  const LoginParams({required this.email, required this.password});
}
```

## üí° Best Practices
- Always validate input parameters before calling repository
- Use specific error messages for different error scenarios
- Keep UseCase methods focused on single responsibility
- Test UseCases with unit tests
- Use meaningful parameter names in Params classes

- Keep UseCase methods focused on single responsibility
- Test UseCases with unit tests
- Use meaningful parameter names in Params classes
