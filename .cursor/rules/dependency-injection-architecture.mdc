---
globs: *.dart
alwaysApply: true
---
# Dependency Injection (DI) Architecture

## Feature DI Structure
Every feature **MUST** have a `di/` directory for dependency injection setup:

```
lib/features/[feature]/
├── di/
│   ├── [feature]_module.dart     # Main DI configuration
│   ├── [feature]_locator.dart    # Instance registration (optional)
│   └── [feature]_exports.dart    # Barrel exports
├── data/
├── domain/
└── presentation/
```

## DI Module Pattern
```dart
// lib/features/auth/di/auth_module.dart
void setupAuthModule(GetIt sl) {
  // Register data sources - SINGLETON
  sl.registerLazySingleton<AuthRemoteDataSource>(
    () => AuthRemoteDataSourceImpl(
      supabaseClient: sl(),
    ),
  );
  
  // Register repositories - SINGLETON
  sl.registerLazySingleton<AuthRepository>(
    () => SupabaseAuthRepository(
      remoteDataSource: sl(),
    ),
  );
  
  // Register services - SINGLETON
  sl.registerLazySingleton<AuthService>(
    () => AuthService(
      repository: sl(),
    ),
  );
  
  // Register use cases - SINGLETON
  sl.registerLazySingleton<LoginUseCase>(() => LoginUseCase(sl()));
  sl.registerLazySingleton<LogoutUseCase>(() => LogoutUseCase(sl()));
  sl.registerLazySingleton<RegisterUseCase>(() => RegisterUseCase(sl()));
  
  // Register blocs - FACTORY (CRITICAL!)
  sl.registerFactory<AuthBloc>(() => AuthBloc(
    loginUseCase: sl(),
    logoutUseCase: sl(),
    registerUseCase: sl(),
  ));
}
```

## Registration Types - CRITICAL RULES

### SINGLETON Registration (`registerLazySingleton`)
**Use for long-lived, stateless components:**
- ✅ **Data Sources** (remote, local)
- ✅ **Repositories** (data layer implementations)
- ✅ **Services** (domain business logic)
- ✅ **Use Cases** (application logic)
- ✅ **Core configurations** (theme, router, etc.)

```dart
// CORRECT - Singleton for stateless services
sl.registerLazySingleton<AuthService>(() => AuthService(sl()));
sl.registerLazySingleton<UserRepository>(() => SupabaseUserRepository(sl()));
sl.registerLazySingleton<LoginUseCase>(() => LoginUseCase(sl()));
```

### FACTORY Registration (`registerFactory`)
**Use for stateful, short-lived components:**
- ✅ **BLoCs/Cubits** (presentation state management)
- ✅ **Controllers** with lifecycle
- ✅ **Temporary objects** that need fresh instances

```dart
// CORRECT - Factory for stateful BLoCs
sl.registerFactory<AuthBloc>(() => AuthBloc(
  loginUseCase: sl(),
  logoutUseCase: sl(),
));

sl.registerFactory<ProfileBloc>(() => ProfileBloc(
  getUserUseCase: sl(),
  updateUserUseCase: sl(),
));
```

### SINGLETON Registration (`registerSingleton`)
**Use ONLY for app-wide configurations:**
- ✅ **Global configurations** (database, network clients)
- ⚠️ **Use sparingly** - prefer `registerLazySingleton`

```dart
// CORRECT - Singleton for global config
sl.registerSingleton<SupabaseClient>(Supabase.instance.client);
```

## Why BLoCs Must Be Factories

### The Problem with Singleton BLoCs
```dart
// ❌ WRONG - Don't do this!
sl.registerLazySingleton<AuthBloc>(() => AuthBloc(sl()));

// Problems:
// 1. Same BLoC instance shared across widgets
// 2. State pollution between different screens
// 3. Memory leaks - BLoC never disposed
// 4. Unpredictable state behavior
```

### The Solution with Factory BLoCs
```dart
// ✅ CORRECT - Always use factory for BLoCs
sl.registerFactory<AuthBloc>(() => AuthBloc(sl()));

// Benefits:
// 1. Fresh BLoC instance for each BlocProvider
// 2. Clean state for each screen/widget
// 3. Proper disposal when widget is destroyed
// 4. Predictable state management
```

### BLoC Usage Pattern
```dart
// In your screen/widget
class LoginScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider<AuthBloc>(
      // Factory creates new instance each time
      create: (context) => sl<AuthBloc>(),
      child: BlocBuilder<AuthBloc, AuthState>(
        builder: (context, state) {
          // Fresh, clean state for this screen
          return LoginForm();
        },
      ),
    );
  }
}
```

## DI Registration Order
**CRITICAL**: Register dependencies in this exact order:

1. **Core Services** (database clients, network clients)
2. **Data Sources** (remote, local data access)
3. **Repositories** (data layer implementations)
4. **Services** (domain business logic)
5. **Use Cases** (application logic)
6. **BLoCs/Cubits** (presentation logic) - LAST!

```dart
void setupAuthModule(GetIt sl) {
  // 1. Core services (if needed)
  // Already registered in main service locator
  
  // 2. Data sources
  sl.registerLazySingleton<AuthRemoteDataSource>(() => AuthRemoteDataSourceImpl(sl()));
  
  // 3. Repositories
  sl.registerLazySingleton<AuthRepository>(() => SupabaseAuthRepository(sl()));
  
  // 4. Services
  sl.registerLazySingleton<AuthService>(() => AuthService(sl()));
  
  // 5. Use cases
  sl.registerLazySingleton<LoginUseCase>(() => LoginUseCase(sl()));
  sl.registerLazySingleton<LogoutUseCase>(() => LogoutUseCase(sl()));
  
  // 6. BLoCs - LAST and as FACTORY
  sl.registerFactory<AuthBloc>(() => AuthBloc(
    loginUseCase: sl(),
    logoutUseCase: sl(),
  ));
}
```

## GetIt Service Locator Pattern

### Core Setup
```dart
// lib/core/di/service_locator.dart
import 'package:get_it/get_it.dart';

final GetIt sl = GetIt.instance;

void setupServiceLocator() {
  // Core services first
  sl.registerLazySingleton<SupabaseClient>(() => Supabase.instance.client);
  
  // Feature modules
  setupAuthModule(sl);
  setupProfileModule(sl);
  setupCompanyModule(sl);
  // ... other modules
}
```

### Feature Module Integration
```dart
// lib/features/auth/di/auth_module.dart
import 'package:get_it/get_it.dart';

void setupAuthModule(GetIt sl) {
  // Register dependencies using GetIt
  sl.registerLazySingleton<AuthRepository>(() => SupabaseAuthRepository(sl()));
  sl.registerFactory<AuthBloc>(() => AuthBloc(sl()));
}
```

### Usage in Widgets
```dart
// In your screen/widget
class LoginScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider<AuthBloc>(
      // GetIt provides fresh instance for factories
      create: (context) => sl<AuthBloc>(),
      child: BlocBuilder<AuthBloc, AuthState>(
        builder: (context, state) {
          return LoginForm();
        },
      ),
    );
  }
}
```

## File Creation Workflow for DI

### DI Configuration Updates (MANDATORY)
When creating ANY file except `pages/` and `widgets/`, the DI module **MUST** be updated with proper registration types:

#### Files That Require DI Updates:
- ✅ **Data Sources** (`data/datasources/`) → `registerLazySingleton`
- ✅ **Repositories** (`data/repositories/`) → `registerLazySingleton`
- ✅ **Services** (`domain/services/`) → `registerLazySingleton`
- ✅ **Use Cases** (`domain/usecases/`) → `registerLazySingleton`
- ✅ **BLoCs/Cubits** (`presentation/bloc/`) → `registerFactory`
- ❌ **Pages** (`presentation/pages/`) - No DI needed
- ❌ **Widgets** (`presentation/widgets/`) - No DI needed

### DI Update Examples:
```dart
// Created: lib/features/auth/domain/usecases/reset_password_use_case.dart
// Update: lib/features/auth/di/auth_module.dart

void setupAuthModule(GetIt sl) {
  // ... existing registrations ...
  
  // ADD: Register new use case as SINGLETON
  sl.registerLazySingleton<ResetPasswordUseCase>(() => ResetPasswordUseCase(sl()));
  
  // UPDATE: Add to bloc constructor (bloc remains FACTORY)
  sl.registerFactory<AuthBloc>(() => AuthBloc(
    loginUseCase: sl(),
    logoutUseCase: sl(),
    registerUseCase: sl(),
    resetPasswordUseCase: sl(), // Add new dependency
  ));
}
```

### File Creation Checklist for DI

#### For DI-Required Files (non-pages/widgets):
1. ✅ Register in DI module (`[feature]_module.dart`)
2. ✅ Use correct registration type:
   - `registerLazySingleton` for data sources, repositories, services, use cases
   - `registerFactory` for BLoCs/Cubits
3. ✅ Follow registration order (dependencies first)
4. ✅ Update dependent registrations (e.g., add to BLoC constructor)
5. ✅ Test DI configuration works

## Testing Considerations
```dart
// lib/features/auth/di/auth_test_module.dart
void setupAuthTestModule(GetIt sl) {
  // Register mocks as singletons for testing
  sl.registerLazySingleton<AuthRepository>(() => MockAuthRepository());
  sl.registerLazySingleton<AuthService>(() => MockAuthService());
  
  // BLoCs still as factories in tests
  sl.registerFactory<AuthBloc>(() => AuthBloc(
    loginUseCase: MockLoginUseCase(),
    logoutUseCase: MockLogoutUseCase(),
  ));
}
```

## Common DI Mistakes to Avoid

### ❌ Wrong Registration Types
```dart
// WRONG - BLoC as singleton
sl.registerLazySingleton<AuthBloc>(() => AuthBloc(sl()));

// WRONG - Repository as factory
sl.registerFactory<AuthRepository>(() => SupabaseAuthRepository(sl()));
```

### ✅ Correct Registration Types
```dart
// CORRECT - BLoC as factory
sl.registerFactory<AuthBloc>(() => AuthBloc(sl()));

// CORRECT - Repository as singleton
sl.registerLazySingleton<AuthRepository>(() => SupabaseAuthRepository(sl()));
```

### ❌ Wrong Registration Order
```dart
// WRONG - BLoC registered before its dependencies
sl.registerFactory<AuthBloc>(() => AuthBloc(sl())); // Will fail!
sl.registerLazySingleton<LoginUseCase>(() => LoginUseCase(sl()));
```

### ✅ Correct Registration Order
```dart
// CORRECT - Dependencies first, then consumers
sl.registerLazySingleton<LoginUseCase>(() => LoginUseCase(sl()));
sl.registerFactory<AuthBloc>(() => AuthBloc(sl())); // Will work!
```

### Other Common Mistakes:
- ❌ Adding use cases without registering in DI
- ❌ Forgetting to update BLoC dependencies
- ❌ Using wrong registration types (singleton vs factory)
- ❌ Wrong registration order in DI module
- ❌ Not using GetIt service locator pattern consistently
- ❌ Using other DI frameworks instead of get_it (riverpod, injectable, etc.)

## Automated Verification
```dart
// Example verification in tests
void main() {
  group('DI Configuration Tests', () {
    test('should resolve all auth dependencies with correct types', () {
      // Setup
      setupAuthModule(sl);
      
      // Verify singletons
      final service1 = sl<AuthService>();
      final service2 = sl<AuthService>();
      expect(identical(service1, service2), true); // Same instance
      
      // Verify factories
      final bloc1 = sl<AuthBloc>();
      final bloc2 = sl<AuthBloc>();
      expect(identical(bloc1, bloc2), false); // Different instances
    });
  });
}
```
