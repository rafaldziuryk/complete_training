---
globs: *.dart
alwaysApply: true
---
# Widget State Management Rules

## MANDATORY: Widget State Restrictions

### ‚ùå FORBIDDEN: Business Data in Widget State
**Widget State classes MUST NOT store business data/state variables:**

```dart
// ‚ùå WRONG: Storing business data in widget state
class _UserListScreenState extends State<UserListScreen> {
  List<UserEntity> _users = [];      // ‚ùå Business data in widget
  bool _isLoading = true;             // ‚ùå Loading state in widget
  String? _errorMessage;              // ‚ùå Error state in widget
  UserEntity? _currentUser;           // ‚ùå Business entity in widget

  @override
  void initState() {
    super.initState();
    _loadUsers(); // ‚ùå Business logic in widget
  }
}
```

### ‚úÖ ALLOWED: UI-Specific State Only
**Widget State should ONLY contain UI-specific state:**

```dart
// ‚úÖ CORRECT: Only UI-specific state in widget
class _UserListScreenState extends State<UserListScreen> {
  // ‚úÖ ALLOWED: UI controllers
  late ScrollController _scrollController;
  late TextEditingController _searchController;
  late AnimationController _animationController;
  
  // ‚úÖ ALLOWED: UI-specific state
  int _currentPageIndex = 0;
  bool _isExpanded = false;
  bool _isPasswordVisible = false;
  double _sliderValue = 0.0;
  
  // ‚úÖ ALLOWED: Form validation UI state
  bool _isFormValid = false;
  String? _formError;
  
  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _searchController = TextEditingController();
    _animationController = AnimationController(vsync: this);
    
    // ‚úÖ ALLOWED: Trigger BLoC event
    context.read<UserBloc>().add(LoadUsers());
  }
}
```

### ‚úÖ CORRECT: Using BLoC State for Business Data
```dart
// ‚úÖ CORRECT: Using BLoC state for business data
class _UserListScreenState extends State<UserListScreen> {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UserBloc, UserState>(
      builder: (context, state) {
        return switch (state) {
          UserLoading() => const CircularProgressIndicator(),
          UserLoaded(users: final users) => _buildUserList(users),
          UserError(message: final error) => _buildErrorWidget(error),
          _ => const SizedBox.shrink(),
        };
      },
    );
  }
  
  Widget _buildUserList(List<UserEntity> users) {
    return ListView.builder(
      controller: _scrollController, // ‚úÖ UI controller
      itemCount: users.length,
      itemBuilder: (context, index) => UserTile(user: users[index]),
    );
  }
}
```

## MANDATORY: Business Logic Restrictions

### ‚ùå FORBIDDEN: Business Logic in Widgets
**Widgets MUST NOT process or calculate business data:**

```dart
// ‚ùå WRONG: Processing data in widget
class _BMIScreenState extends State<BMIScreen> {
  void _updateBMI() {
    final newBMI = BMICalculator.calculateBMI(_weight, _height);
    final newCategory = BMICalculator.categorizeBMI(newBMI);
    
    setState(() {
      _bmi = newBMI;        // ‚ùå Business data in widget
      _category = newCategory; // ‚ùå Business data in widget
    });
  }
}

// ‚ùå WRONG: API calls in widget
class _UserScreenState extends State<UserScreen> {
  void _loadUsers() async {
    final users = await userRepository.getUsers(); // ‚ùå Direct API call
    setState(() {
      _users = users; // ‚ùå Business data in widget
    });
  }
}

// ‚ùå WRONG: Widget calling UseCase directly
class _UserScreenState extends State<UserScreen> {
  void _loadUsers() {
    final result = sl<GetUsersUseCase>()(GetUsersParams()); // ‚ùå Direct UseCase call
    // Widget should not call UseCases directly!
  }
}
```

### ‚úÖ CORRECT: Business Logic in BLoC
```dart
// ‚úÖ CORRECT: Widget only triggers BLoC event
class _BMIScreenState extends State<BMIScreen> {
  void _updateBMI() {
    context.read<BMIBloc>().add(CalculateBMIRequested(
      weight: _weight,
      height: _height,
    ));
  }
}

// ‚úÖ CORRECT: BLoC handles business logic
class BMIBloc extends Bloc<BMIEvent, BMIState> {
  final CalculateBMIUseCase _calculateBMIUseCase;
  
  void _onCalculateBMI(CalculateBMIRequested event, Emitter<BMIState> emit) {
    final result = _calculateBMIUseCase(CalculateBMIParams(
      weight: event.weight,
      height: event.height,
    ));
    
    result.fold(
      (failure) => emit(BMIError(failure.message)),
      (bmiData) => emit(BMICalculated(
        bmi: bmiData.bmi,
        category: bmiData.category,
      )),
    );
  }
}
```

## MANDATORY: Widget Interaction Patterns

### ‚úÖ CORRECT: Widget Event Triggers
```dart
// ‚úÖ CORRECT: Widget triggers BLoC events
class LoginForm extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TextField(
          onChanged: (value) {
            // ‚úÖ ALLOWED: UI-specific state
            _email = value;
          },
        ),
        ElevatedButton(
          onPressed: () {
            // ‚úÖ CORRECT: Trigger BLoC event
            context.read<LoginBloc>().add(LoginRequested(
              email: _email,
              password: _password,
            ));
          },
          child: const Text('Login'),
        ),
      ],
    );
  }
}
```

### ‚úÖ CORRECT: Reactive UI Updates
```dart
// ‚úÖ CORRECT: Using BlocBuilder for reactive UI
class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UserBloc, UserState>(
      builder: (context, state) {
        return switch (state) {
          UserLoading() => const CircularProgressIndicator(),
          UserLoaded(user: final user) => UserProfileWidget(user: user),
          UserError(message: final error) => ErrorWidget(message: error),
          _ => const SizedBox.shrink(),
        };
      },
    );
  }
}
```

## ‚ùå Violations
- **Widget State classes storing business data/state variables** (e.g., `List<CardEntity> _cards = []`, `bool _isLoading = true`, `String? _error`)
- **Business logic in widget classes** (e.g., API calls, data processing, state management in `initState()` or widget methods)
- **Data processing or calculations in widget methods** (e.g., BMI calculations, data transformations, business logic in widget state)
- **Widgets calling UseCases directly** - widgets must only communicate with BLoC, not with UseCases
- Using `setState()` for business data updates
- Storing entities or business objects in widget state

## ‚úÖ Correct Patterns
- **Widget State should only contain UI-specific state** (e.g., `TextEditingController`, `AnimationController`, `ScrollController`)
- **All business data must come from BLoC state** - never duplicate data between BLoC and widget state
- **Use BlocBuilder/BlocListener for reactive UI updates** instead of manual state management in widgets
- **Trigger BLoC events from widget interactions** (e.g., `context.read<UserBloc>().add(LoadUsers())`) instead of calling services directly
- **All data processing and calculations must be in BLoC** - widgets should only trigger events and display results
- **BLoC calls UseCases for business logic** - widgets never call UseCases directly, only through BLoC

## üí° Best Practices
- Keep widget state minimal and UI-focused
- Use BLoC state for all business data
- Trigger BLoC events for user interactions
- Use BlocBuilder for reactive UI updates
- Never call UseCases directly from widgets
- Test widget interactions with BLoC events
